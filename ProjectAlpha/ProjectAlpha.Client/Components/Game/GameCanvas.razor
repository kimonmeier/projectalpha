@using System.Diagnostics
@using System.Numerics
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions.Canvas.WebGL
@using MudBlazor.Extensions

<BECanvas Width="1000" Height="1000" @ref="_canvasReference"></BECanvas>

<button @onclick="Rerender">Rerender</button>
<button @onclick="PrintBenchmark">Print Benchmark</button>
<button @onclick="StartFpsSimulation">Start FPS Simulation</button>

<div>
    Frames rendered: @_framesRendered
</div>
<div>
    Average frame render time: @_averageFrameRenderTime ms
</div>
<div>
    Average FPS: @_averageFPS
</div>
<input type="number" class="text-black" @bind-value="_length"/>

@code {
    private WebGLContext _context;

    private BECanvasComponent _canvasReference;
    private WebGLProgram _program;
    private BenchmarkHelper _benchmarkHelper = new BenchmarkHelper();

    // Caching von WebGL-Objekten und dem Random-Generator
    private WebGLBuffer _pixelBuffer;
    private readonly Random _random = new();

    private uint _vertexPositionAttributeLocation;
    private uint _vertexColorAttributeLocation;

    private int _framesRendered = 0;
    private double _averageFrameRenderTime = 0;
    private double _averageFPS = 0;

    private int _length = 100;

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _context = await _canvasReference.CreateWebGLAsync(new WebGLContextAttributes() { Antialias = false });
            
            await PrepareScene();
            await RenderScene();
        }
    }

    private async Task PrepareScene()
    {
        _benchmarkHelper.Start("PrepareScene");
        _program = await CreateShaders();

        await _context.UseProgramAsync(_program);

        _vertexPositionAttributeLocation = (uint)await _context.GetAttribLocationAsync(_program, "vertexPosition");
        _vertexColorAttributeLocation = (uint)await _context.GetAttribLocationAsync(_program, "a_color");

        // Buffer einmalig erstellen
        _pixelBuffer = await _context.CreateBufferAsync();
        await _context.BindBufferAsync(BufferType.ARRAY_BUFFER, _pixelBuffer);

        // Vertex-Attribute einmalig einrichten
        const int stride = 5 * sizeof(float);
        await _context.VertexAttribPointerAsync(_vertexPositionAttributeLocation, 2, DataType.FLOAT, false, stride, 0);
        await _context.EnableVertexAttribArrayAsync(_vertexPositionAttributeLocation);

        await _context.VertexAttribPointerAsync(_vertexColorAttributeLocation, 3, DataType.FLOAT, false, stride, 2 * sizeof(float));
        await _context.EnableVertexAttribArrayAsync(_vertexColorAttributeLocation);

        _benchmarkHelper.Stop("PrepareScene");
    }

    private async Task RenderScene()
    {
        _benchmarkHelper.Start("RenderScene");
        await _context.ViewportAsync(0, 0, 1000, 1000);
        await _context.ClearColorAsync(0.08f, 0.08f, 0.08f, 1);
        await _context.ClearAsync(BufferBits.COLOR_BUFFER_BIT);
        await _context.ClearAsync(BufferBits.DEPTH_BUFFER_BIT);

        await DrawPixels();
        _benchmarkHelper.Stop("RenderScene");
    }

    private async Task<WebGLProgram> CreateShaders()
    {
        // ... (Die CreateShaders-Methode bleibt unverändert)
        _benchmarkHelper.Start("CreateShaders");
        var vertexSharedSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec2 vertexPosition;
                                     in vec3 a_color;

                                     out vec4 v_color;

                                     void main() {
                                       gl_Position = vec4(vertexPosition, 0.0, 1.0);
                                       v_color = vec4(a_color, 1.0);
                                     }

                                     ";
        var vertexShader = await _context.CreateShaderAsync(ShaderType.VERTEX_SHADER);
        await _context.ShaderSourceAsync(vertexShader, vertexSharedSourceCode);
        await _context.CompileShaderAsync(vertexShader);

        var isVertextShaderCompiled = await _context.GetShaderParameterAsync<bool>(vertexShader, ShaderParameter.COMPILE_STATUS);
        if (!isVertextShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(vertexShader);
            Console.WriteLine(shaderLog);
        }


        var fragmentShaderSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec4 v_color;
                                     
                                     out vec4 outColor;
                                     
                                     void main() {
                                       outColor = v_color;
                                     }
                                     ";
        var fragmentShader = await _context.CreateShaderAsync(ShaderType.FRAGMENT_SHADER);
        await _context.ShaderSourceAsync(fragmentShader, fragmentShaderSourceCode);
        await _context.CompileShaderAsync(fragmentShader);

        var isFragmentShaderCompiled = await _context.GetShaderParameterAsync<bool>(fragmentShader, ShaderParameter.COMPILE_STATUS);
        if (!isFragmentShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(fragmentShader);
            Console.WriteLine(shaderLog);
        }

        var programm = await _context.CreateProgramAsync();
        await _context.AttachShaderAsync(programm, vertexShader);
        await _context.AttachShaderAsync(programm, fragmentShader);
        await _context.LinkProgramAsync(programm);

        _benchmarkHelper.Stop("CreateShaders");

        var isProgrammLinked = await _context.GetProgramParameterAsync<bool>(programm, ProgramParameter.LINK_STATUS);
        if (isProgrammLinked)
        {
            return programm;
        }

        var programLog = await _context.GetProgramInfoLogAsync(programm);
        Console.WriteLine(programLog);

        throw new Exception("Failed to link the Programm");
    }

    private async Task DrawPixels()
    {
        _benchmarkHelper.Start("DrawPixels");

        var size = (float)_length;
        var vertexCount = _length * _length * 6;
        var vertexData = new float[vertexCount * 5]; // Direktes Array statt Liste
        int index = 0;

        for (int y = 0; y < _length; y++)
        {
            float startY = (y * 2 / size) - 1f;
            float endY = startY + (2 / size);

            for (int x = 0; x < _length; x++)
            {
                float startX = (x * 2 / size) - 1f;
                float endX = startX + (2 / size);
                
                // Vermeidung von Objekt-Allokationen in der Schleife
                var colorR = (float)_random.NextDouble();
                var colorG = (float)_random.NextDouble();
                var colorB = (float)_random.NextDouble();

                // Vertex-Daten direkt ins Array schreiben
                // Dreieck 1
                vertexData[index++] = startX; vertexData[index++] = startY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;
                vertexData[index++] = endX; vertexData[index++] = startY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;
                vertexData[index++] = startX; vertexData[index++] = endY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;

                // Dreieck 2
                vertexData[index++] = endX; vertexData[index++] = startY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;
                vertexData[index++] = endX; vertexData[index++] = endY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;
                vertexData[index++] = startX; vertexData[index++] = endY; vertexData[index++] = colorR; vertexData[index++] = colorG; vertexData[index++] = colorB;
            }
        }

        // Bestehenden Buffer binden und nur die Daten aktualisieren
        await _context.BindBufferAsync(BufferType.ARRAY_BUFFER, _pixelBuffer);
        await _context.BufferDataAsync(BufferType.ARRAY_BUFFER, vertexData, BufferUsageHint.DYNAMIC_DRAW);

        await _context.DrawArraysAsync(Primitive.TRIANGLES, 0, vertexCount);
        // Buffer nicht mehr löschen

        _benchmarkHelper.Stop("DrawPixels");
    }

    private async Task Rerender()
    {
        await RenderScene();
    }

    private void PrintBenchmark()
    {
        _benchmarkHelper.Print();
    }

    private async Task StartFpsSimulation()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        var runs = 0;
        var waitTime = TimeSpan.FromSeconds(10).TotalMilliseconds;

        while (stopwatch.ElapsedMilliseconds < waitTime)
        {
            await RenderScene();
            await Task.Delay(1);
            runs += 1;
        }
        stopwatch.Stop();

        _framesRendered = runs;
        _averageFrameRenderTime = waitTime / runs;
        _averageFPS = 1000 / _averageFrameRenderTime;
    }
}