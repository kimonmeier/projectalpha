@using System.Numerics
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions.Canvas.WebGL

<BECanvas Width="1000" Height="1000" @ref="_canvasReference"></BECanvas>

<button @onclick="Rerender">Rerender</button>
<button @onclick="PrintBenchmark">Print Benchmark</button>
@code {
    private WebGLContext _context;

    private BECanvasComponent _canvasReference;
    private WebGLProgram _program;
    private BenchmarkHelper _benchmarkHelper = new BenchmarkHelper();

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        _context = await _canvasReference.CreateWebGLAsync();

        if (firstRender)
        {
            await PrepareScene();
            await RenderScene();
        }
    }

    private async Task PrepareScene()
    {
        _benchmarkHelper.Start("PrepareScene");
        _program = await CreateShaders();

        await _context.UseProgramAsync(_program);
        _benchmarkHelper.Stop("PrepareScene");
    }

    private async Task RenderScene()
    {
        _benchmarkHelper.Start("RenderScene");
        await _context.ViewportAsync(0, 0, 1000, 1000);
        await _context.ClearColorAsync(0.08f, 0.08f, 0.08f, 1);
        await _context.ClearAsync(BufferBits.COLOR_BUFFER_BIT);
        await _context.ClearAsync(BufferBits.DEPTH_BUFFER_BIT);

        await DrawPixels();
        _benchmarkHelper.Stop("RenderScene");
    }

    private async Task<WebGLProgram> CreateShaders()
    {
        _benchmarkHelper.Start("CreateShaders");
        var vertexSharedSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec2 vertexPosition;
                                     in vec3 a_color;

                                     out vec4 v_color;

                                     void main() {
                                       gl_Position = vec4(vertexPosition, 0.0, 1.0);
                                       v_color = vec4(a_color, 1.0);
                                     }

                                     ";
        var vertexShader = await _context.CreateShaderAsync(ShaderType.VERTEX_SHADER);
        await _context.ShaderSourceAsync(vertexShader, vertexSharedSourceCode);
        await _context.CompileShaderAsync(vertexShader);

        var isVertextShaderCompiled = await _context.GetShaderParameterAsync<bool>(vertexShader, ShaderParameter.COMPILE_STATUS);
        if (!isVertextShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(vertexShader);
            Console.WriteLine(shaderLog);
        }


        var fragmentShaderSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec4 v_color;
                                     
                                     out vec4 outColor;
                                     
                                     void main() {
                                       outColor = v_color;
                                     }
                                     ";
        var fragmentShader = await _context.CreateShaderAsync(ShaderType.FRAGMENT_SHADER);
        await _context.ShaderSourceAsync(fragmentShader, fragmentShaderSourceCode);
        await _context.CompileShaderAsync(fragmentShader);

        var isFragmentShaderCompiled = await _context.GetShaderParameterAsync<bool>(fragmentShader, ShaderParameter.COMPILE_STATUS);
        if (!isFragmentShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(fragmentShader);
            Console.WriteLine(shaderLog);
        }

        var programm = await _context.CreateProgramAsync();
        await _context.AttachShaderAsync(programm, vertexShader);
        await _context.AttachShaderAsync(programm, fragmentShader);
        await _context.LinkProgramAsync(programm);
        
        _benchmarkHelper.Stop("CreateShaders");

        var isProgrammLinked = await _context.GetProgramParameterAsync<bool>(programm, ProgramParameter.LINK_STATUS);
        if (isProgrammLinked)
        {
            return programm;
        }

        var programLog = await _context.GetProgramInfoLogAsync(programm);
        Console.WriteLine(programLog);

        throw new Exception("Failed to link the Programm");
    }

    private async Task DrawPixels()
    {
        _benchmarkHelper.Start("DrawPixels");

        var random = new Random();
        var vertexPositionAttributeLocation = (uint) await _context.GetAttribLocationAsync(_program, "vertexPosition");
        var vertexColorAttributeLocation = (uint) await _context.GetAttribLocationAsync(_program, "a_color");
        for (int y = 0; y < 100; y++)
        {
            float startY = (y * 2 / 100f) - 1f;
            float endY = startY + (2 / 100f);
            
            for (int x = 0; x < 100; x++)
            {
                float startX = (x * 2 / 100f) - 1f;
                float endX = startX + (2 / 100f);

                await DrawPixelRaw(vertexPositionAttributeLocation, vertexColorAttributeLocation, new Vector2(startX, startY), new Vector2(endX, endY), new Vector3(1, 1, 1));
            }
        }
        _benchmarkHelper.Stop("DrawPixels");
    }
    
    private async Task DrawPixelRaw(uint attributePositionLocation, uint attributeColorLocation, Vector2 startCoordinates, Vector2 endCoordinates, Vector3 color)
    {
        _benchmarkHelper.Start("DrawPixelRaw");
        float[] topLeft = [startCoordinates.X, startCoordinates.Y];
        float[] topRight = [endCoordinates.X, startCoordinates.Y];
        float[] bottomLeft = [startCoordinates.X, endCoordinates.Y];
        float[] bottomRight = [endCoordinates.X, endCoordinates.Y];


        float[] colorBufferData =
        [
            color.X,
            color.Y,
            color.Z
        ];

        // Define Coordinates for one Element
        float[] verticesCoordinatesTriangle1 =
        [
            // Top Left
            ..topLeft, ..colorBufferData,

            // Top Right
            ..topRight, ..colorBufferData,

            // Bottom Left
            ..bottomLeft, ..colorBufferData,
        ];
        
        // Define Coordinates for one Element
        float[] verticesCoordinatesTriangle2 =
        [

            // Top Right
            ..topRight, ..colorBufferData,
            
            // Bottom Left
            ..bottomRight, ..colorBufferData,
            
            // Top Left
            ..bottomLeft, ..colorBufferData,
        ];

        await DrawTriangle(attributePositionLocation, attributeColorLocation, verticesCoordinatesTriangle1, colorBufferData);
        await DrawTriangle(attributePositionLocation, attributeColorLocation, verticesCoordinatesTriangle2, colorBufferData);
        _benchmarkHelper.Stop("DrawPixelRaw");
    }

    private async Task DrawTriangle(uint attributePositionLocation, uint attributeColorLocation, float[] verticesCoordinates, float[] colorData)
    {
        _benchmarkHelper.Start("DrawTriangle");
        var rectangleGeoBuffer = await _context.CreateBufferAsync();
        await _context.BindBufferAsync(BufferType.ARRAY_BUFFER, rectangleGeoBuffer);
        await _context.BufferDataAsync(BufferType.ARRAY_BUFFER, verticesCoordinates, BufferUsageHint.STATIC_DRAW);
        const int stride = 5 * sizeof(float);
        await _context.VertexAttribPointerAsync(
            attributePositionLocation,
            2,
            DataType.FLOAT,
            false,
            stride,
            0
        );
        await _context.EnableVertexAttribArrayAsync(attributePositionLocation);
        
        await _context.VertexAttribPointerAsync(
            attributeColorLocation,
            3,
            DataType.FLOAT,
            false,
            stride,
            2 * sizeof(float)
        );
        await _context.EnableVertexAttribArrayAsync(attributeColorLocation);

        await _context.DrawArraysAsync(Primitive.TRIANGLES, 0, 3);
        _benchmarkHelper.Stop("DrawTriangle");
    }

    private async Task Rerender()
    {
        await RenderScene();
    }

    private void PrintBenchmark()
    {
        this._benchmarkHelper.Print();
    }

}