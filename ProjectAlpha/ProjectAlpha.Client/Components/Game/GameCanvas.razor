@using System.Diagnostics
@using System.Numerics
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions.Canvas.WebGL
@using MudBlazor.Extensions

<BECanvas Width="1000" Height="1000" @ref="_canvasReference"></BECanvas>

<button @onclick="Rerender">Rerender</button>
<button @onclick="PrintBenchmark">Print Benchmark</button>
<button @onclick="StartFpsSimulation">Print Benchmark</button>

<div>
    Frames rendered: @_framesRendered
</div>
<div>
    Average frame render time: @_averageFrameRenderTime ms
</div>
<div>
    Average FPS: @_averageFPS
</div>
<input type="number" class="text-black" @bind-value="_length" />

@code {
    private WebGLContext _context;

    private BECanvasComponent _canvasReference;
    private WebGLProgram _program;
    private BenchmarkHelper _benchmarkHelper = new BenchmarkHelper();

    private uint _vertexPositionAttributeLocation;
    private uint _vertexColorAttributeLocation;

    private int _framesRendered = 0;
    private double _averageFrameRenderTime = 0;
    private double _averageFPS = 0;

    private int _length = 100;
    
    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        _context = await _canvasReference.CreateWebGLAsync();

        if (firstRender)
        {
            await PrepareScene();
            await RenderScene();
        }
    }

    private async Task PrepareScene()
    {
        _benchmarkHelper.Start("PrepareScene");
        _program = await CreateShaders();

        await _context.UseProgramAsync(_program);

        _vertexPositionAttributeLocation = (uint)await _context.GetAttribLocationAsync(_program, "vertexPosition");
        _vertexColorAttributeLocation = (uint)await _context.GetAttribLocationAsync(_program, "a_color");

        _benchmarkHelper.Stop("PrepareScene");
    }

    private async Task RenderScene()
    {
        _benchmarkHelper.Start("RenderScene");
        await _context.ViewportAsync(0, 0, 1000, 1000);
        await _context.ClearColorAsync(0.08f, 0.08f, 0.08f, 1);
        await _context.ClearAsync(BufferBits.COLOR_BUFFER_BIT);
        await _context.ClearAsync(BufferBits.DEPTH_BUFFER_BIT);

        await DrawPixels();
        _benchmarkHelper.Stop("RenderScene");
    }

    private async Task<WebGLProgram> CreateShaders()
    {
        _benchmarkHelper.Start("CreateShaders");
        var vertexSharedSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec2 vertexPosition;
                                     in vec3 a_color;

                                     out vec4 v_color;

                                     void main() {
                                       gl_Position = vec4(vertexPosition, 0.0, 1.0);
                                       v_color = vec4(a_color, 1.0);
                                     }

                                     ";
        var vertexShader = await _context.CreateShaderAsync(ShaderType.VERTEX_SHADER);
        await _context.ShaderSourceAsync(vertexShader, vertexSharedSourceCode);
        await _context.CompileShaderAsync(vertexShader);

        var isVertextShaderCompiled = await _context.GetShaderParameterAsync<bool>(vertexShader, ShaderParameter.COMPILE_STATUS);
        if (!isVertextShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(vertexShader);
            Console.WriteLine(shaderLog);
        }


        var fragmentShaderSourceCode = @"#version 300 es
                                     precision mediump float;

                                     in vec4 v_color;
                                     
                                     out vec4 outColor;
                                     
                                     void main() {
                                       outColor = v_color;
                                     }
                                     ";
        var fragmentShader = await _context.CreateShaderAsync(ShaderType.FRAGMENT_SHADER);
        await _context.ShaderSourceAsync(fragmentShader, fragmentShaderSourceCode);
        await _context.CompileShaderAsync(fragmentShader);

        var isFragmentShaderCompiled = await _context.GetShaderParameterAsync<bool>(fragmentShader, ShaderParameter.COMPILE_STATUS);
        if (!isFragmentShaderCompiled)
        {
            var shaderLog = await _context.GetShaderInfoLogAsync(fragmentShader);
            Console.WriteLine(shaderLog);
        }

        var programm = await _context.CreateProgramAsync();
        await _context.AttachShaderAsync(programm, vertexShader);
        await _context.AttachShaderAsync(programm, fragmentShader);
        await _context.LinkProgramAsync(programm);

        _benchmarkHelper.Stop("CreateShaders");

        var isProgrammLinked = await _context.GetProgramParameterAsync<bool>(programm, ProgramParameter.LINK_STATUS);
        if (isProgrammLinked)
        {
            return programm;
        }

        var programLog = await _context.GetProgramInfoLogAsync(programm);
        Console.WriteLine(programLog);

        throw new Exception("Failed to link the Programm");
    }

    private async Task DrawPixels()
    {
        _benchmarkHelper.Start("DrawPixels");

        var random = new Random();
        var vertexData = new List<float>();
        var size = (float)_length;
        
        for (int y = 0; y < size; y++)
        {
            float startY = (y * 2 / size) - 1f;
            float endY = startY + (2 / size);

            for (int x = 0; x < size; x++)
            {
                float startX = (x * 2 / size) - 1f;
                float endX = startX + (2 / size);
                var color = new Vector3((float)random.NextDouble(), (float)random.NextDouble(), (float)random.NextDouble());

                // Ein Rechteck besteht aus zwei Dreiecken
                // Dreieck 1
                vertexData.AddRange([
                    startX, startY, color.X, color.Y, color.Z
                ]); // Oben Links
                vertexData.AddRange([
                    endX, startY, color.X, color.Y, color.Z
                ]); // Oben Rechts
                vertexData.AddRange([
                    startX, endY, color.X, color.Y, color.Z
                ]); // Unten Links

                // Dreieck 2
                vertexData.AddRange([
                    endX, startY, color.X, color.Y, color.Z
                ]); // Oben Rechts
                vertexData.AddRange([
                    endX, endY, color.X, color.Y, color.Z
                ]); // Unten Rechts
                vertexData.AddRange([
                    startX, endY, color.X, color.Y, color.Z
                ]); // Unten Links
            }
        }

        var pixelBuffer = await _context.CreateBufferAsync();
        await _context.BindBufferAsync(BufferType.ARRAY_BUFFER, pixelBuffer);
        await _context.BufferDataAsync(BufferType.ARRAY_BUFFER, vertexData.ToArray(), BufferUsageHint.DYNAMIC_DRAW);

        const int stride = 5 * sizeof(float);
        await _context.VertexAttribPointerAsync(_vertexPositionAttributeLocation, 2, DataType.FLOAT, false, stride, 0);
        await _context.EnableVertexAttribArrayAsync(_vertexPositionAttributeLocation);

        await _context.VertexAttribPointerAsync(_vertexColorAttributeLocation, 3, DataType.FLOAT, false, stride, 2 * sizeof(float));
        await _context.EnableVertexAttribArrayAsync(_vertexColorAttributeLocation);

        await _context.DrawArraysAsync(Primitive.TRIANGLES, 0, vertexData.Count / 5);

        _benchmarkHelper.Stop("DrawPixels");
    }

    private async Task Rerender()
    {
        await RenderScene();
    }

    private void PrintBenchmark()
    {
        this._benchmarkHelper.Print();
    }

    private async Task StartFpsSimulation()
    {
        Stopwatch stopwatch = Stopwatch.StartNew();

        var runs = 0;
        var waitTime = TimeSpan.FromSeconds(10).TotalMilliseconds;
        
        while (stopwatch.ElapsedMilliseconds < waitTime)
        {
            await RenderScene();
            await Task.Delay(1);
            runs += 1;
        }
        stopwatch.Stop();

        _framesRendered = runs;
        _averageFrameRenderTime = waitTime / runs;
        _averageFPS = 1000 / _averageFrameRenderTime;
    }

}